# -*- coding: utf-8 -*-
"""Mini_project.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WM_VXZwrVlrvhIy2qUesD3qQOOafUmvy
"""

# Importing necessary libraries
import numpy as np
import pandas as pd
import seaborn as sns
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression, LinearRegression
from sklearn.metrics import accuracy_score, log_loss, confusion_matrix, ConfusionMatrixDisplay, classification_report
from sklearn.tree import DecisionTreeClassifier, plot_tree
import matplotlib.pyplot as plt
from sklearn.model_selection import KFold, cross_val_score, GridSearchCV, StratifiedKFold
import warnings

# Suppressing warnings for cleaner output
warnings.filterwarnings("ignore")

# Importing LabelEncoder for encoding categorical variables
from sklearn.preprocessing import LabelEncoder

# Reading the CSV file into a DataFrame
df = pd.read_csv("/content/diabetes_prediction_dataset.csv")

# Checking for null values in the DataFrame
df.isnull().sum()

# Dropping rows with null values
df = df.dropna()

# Using LabelEncoder to encode the 'smoking_history' column
label_encoder = LabelEncoder()
df['smoking_history'] = label_encoder.fit_transform(df['smoking_history'])

# Creating dummy variables for categorical columns
df1 = pd.get_dummies(df, drop_first=True)

# Displaying data types of columns in the DataFrame
print(df1.dtypes)

# Creating boxplots for the 'bmi', 'HbA1c_level', and 'blood_glucose_level' columns
sns.boxplot(x='bmi', data=df1)
sns.boxplot(x='HbA1c_level', data=df1)
sns.boxplot(x='blood_glucose_level', data=df1)

# Function to plot histograms for all columns in the DataFrame
def plotgraph(df):
    for column in df1:
        plt.figure(figsize=(16, 5))
        plt.subplot(1, 2, 1)
        sns.distplot(df[column])
        plt.show()

# Calling the plotgraph function on the original DataFrame df1
plotgraph(df1)

# Function to drop outliers in specified columns
def drop_outliers(df, columns):
    for column_name in columns:
        # Calculate IQR
        Q1 = df[column_name].quantile(0.25)
        Q3 = df[column_name].quantile(0.75)
        IQR = Q3 - Q1

        # Define Thresholds
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR

        # Identify Outliers
        outliers = (df[column_name] < lower_bound) | (df[column_name] > upper_bound)

        # Drop Rows with Outliers
        new_df = df[~outliers]

    return new_df

# Example usage of the drop_outliers function
# Assuming df1 is your DataFrame and columns_to_drop is a list of column names
columns_to_drop = ['bmi']
drop_outliers(df1, columns_to_drop)

# Calculating IQR for all columns in the original DataFrame df
Q1 = df.quantile(0.25)
Q3 = df.quantile(0.75)
IQR = Q3 - Q1

# Calculating lower and upper bounds for outlier detection
min_bound = Q1 - 1.5 * IQR
max_bound = Q3 + 1.5 * IQR

# Creating a new DataFrame df_out containing rows without outliers
df_out = df1[~((df1 < min_bound) | (df1 > max_bound)).any(axis=1)]
print("Before:", df1.shape, "After:", df_out.shape)

# Creating boxplots for 'bmi' before and after removing outliers
sns.boxplot(x='bmi', data=df1)
sns.boxplot(x='bmi', data=df_out)

# Calling the plotgraph function on the original DataFrame df1
plotgraph(df1)

# Creating a boxplot for 'bmi' after removing outliers
sns.boxplot(x='bmi', data=df_out)

# Displaying the shape, head, and entire DataFrame df_out after removing outliers
print(df_out.shape)
df_out.head()
df_out
